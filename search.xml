<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ch3-李群与李代数</title>
      <link href="2020/12/10/SLAM/14%E8%AE%B2/ch3-%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"/>
      <url>2020/12/10/SLAM/14%E8%AE%B2/ch3-%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>视觉SLAM14讲的课后习题以及深蓝的习题解答。</p><p>本节对应十四讲中的Ch4.</p><a id="more"></a><h2 id="深蓝的课后习题">深蓝的课后习题</h2><h3 id="群的性质">群的性质</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171711843.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171711843.png" srcset="data:image/png;base64,666" alt="image-20201202171711843" style="zoom:80%;" /></p><ul><li><span class="math inline">\(\{ {\mathbb{Z},+}\}\)</span><strong>为群。</strong><ul><li>封闭性：<span class="math inline">\(\forall Z 1, Z 2 \in \mathbb{Z},(Z 1+Z 2) \in \mathbb{Z}\)</span>，即对于任意两个整数的加法仍为整数，满足条件。</li><li>结合律：<span class="math inline">\(\forall Z 1, Z 2, Z 3 \in \mathbb{Z},(Z 1+Z 2)+Z 3=Z 1+(Z 2+Z 3)\)</span>，满足条件。</li><li>幺元：<span class="math inline">\(\exists \mathrm{Z} 0 \in \mathbb{Z}, \mathrm{Z} 0=0, \forall \mathrm{Z} \in \mathrm{Z}, \mathrm{Z}+0=0+\mathrm{Z}=\mathrm{Z}\)</span>，满足条件。</li><li>逆：<span class="math inline">\(\forall \mathrm{Z} \in \mathbb{Z}, \exists \mathrm{Z}^{-1} \in \mathbb{Z}, \mathrm{Z}^{-1}=-\mathrm{Z}, \mathrm{Z}+(-\mathrm{Z})=0\)</span>，满足条件。</li></ul></li><li><span class="math inline">\(\{\mathbb{N},+\}\)</span><strong>为不为群。</strong><ul><li>封闭性：与<span class="math inline">\(\{ {\mathbb{Z},+}\}\)</span>群同理，满足条件。</li><li>结合律：与<span class="math inline">\(\{ {\mathbb{Z},+}\}\)</span>群同理，满足条件。</li><li>幺元：与<span class="math inline">\(\{ {\mathbb{Z},+}\}\)</span>群同理，满足条件。</li><li>逆：<strong>不存在</strong><span class="math inline">\(\forall \mathrm{N} \in \mathbb{N}, \exists \mathrm{N}^{-1} \in \mathbb{N}, \mathrm{N}^{-1}=-\mathrm{N}, \mathrm{N}+(-\mathrm{N})=C\)</span>，不满足条件。</li></ul></li></ul><h3 id="验证向量叉乘的李代数性质">验证向量叉乘的李代数性质</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171724956.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171724956.png" srcset="data:image/png;base64,666" alt="image-20201202171724956" style="zoom:67%;" /></p><p><strong>证明：</strong></p><p>验证：<span class="math inline">\(\mathfrak{g}=\left(\mathbb{R}^{3}, \mathbb{R}, \times\right)\)</span>满足李代数的性质，设<span class="math inline">\(\boldsymbol {x}=(x_1, x_{2}, x_{3}),\boldsymbol {y}=(y_1, y_{2}, y_{3}),\boldsymbol {z}=(z_1, z_{2}, z_{3})\)</span>,其中<span class="math inline">\(\boldsymbol {x,y,z} \in \mathbb{R}^{3} , x_i,y_i,z_i \in R\)</span>.</p><ul><li>封闭性：</li></ul><p><span class="math display">\[[\boldsymbol x,\boldsymbol y]=\left|\begin{array}{lll}i &amp; j &amp; k \\x_{1} &amp; x_{2} &amp; x_{3} \\y_{1} &amp; y_{2} &amp; y_{3}\end{array}\right|=\left[\begin{array}{l}x_{2} y_{3}-x_{3} y_{2} \\x_{3} y_{1}-x_{1} y_{3} \\x_{1} y_{2}-x_{2} y_{1}\end{array}\right] \in \mathbb{R}^{3}\]</span></p><p><strong>满足封闭性。</strong></p><ul><li>双线性：</li></ul><p><span class="math display">\[[a \boldsymbol{x}+b \boldsymbol{y}, \boldsymbol{z}]=(a \boldsymbol{x}+b \boldsymbol{y}) \times \boldsymbol{z}=a\boldsymbol{x} \times\boldsymbol{z} + b\boldsymbol{y} \times\boldsymbol{z}=a[\boldsymbol{x}, \boldsymbol{z}]+b[\boldsymbol{y}, \boldsymbol{z}]\]</span></p><p><span class="math display">\[[ \boldsymbol{z},a \boldsymbol{x}+b \boldsymbol{y},]= \boldsymbol{z} \times(a \boldsymbol{x}+b \boldsymbol{y}) =a\boldsymbol{z} \times\boldsymbol{x} + b\boldsymbol{z} \times\boldsymbol{y}=a[\boldsymbol{z}, \boldsymbol{x}]+b[\boldsymbol{z}, \boldsymbol{y}]\]</span></p><p><strong>满足双线性。</strong></p><ul><li>自反性：</li></ul><p><span class="math display">\[[\boldsymbol x,\boldsymbol x]=\left|\begin{array}{lll}i &amp; j &amp; k \\x_{1} &amp; x_{2} &amp; x_{3} \\x_{1} &amp; x_{2} &amp; x_{3}\end{array}\right|=0\]</span></p><p><strong>满足自反性。</strong></p><ul><li>雅可比等价：</li></ul><p>由<strong>矢量的二重叉积</strong>公式$ $,进行化简可得： <span class="math display">\[\begin{aligned}&amp;\quad [\boldsymbol{x},[\boldsymbol{y}, \boldsymbol{z}]]+[\boldsymbol{y},[\boldsymbol{x}, \boldsymbol{z}]]+[\boldsymbol{z},[\boldsymbol{x}, \boldsymbol{y}]]\\&amp;=\boldsymbol{(x \cdot z)y-(y \cdot z)x} + \boldsymbol{(y \cdot x)z-(z \cdot x)y}+\boldsymbol{(z \cdot y)x-(x \cdot y)z} \\&amp;=0\end{aligned}\]</span> 证毕。</p><h3 id="推导-se3-的指数映射">推导 SE(3) 的指数映射</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171739112.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171739112.png" srcset="data:image/png;base64,666" alt="image-20201202171739112" style="zoom:67%;" /></p><p><strong>证明：</strong></p><p>已知：</p><ul><li><span class="math inline">\(\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}=\boldsymbol{a} \boldsymbol{a}^{T}-\boldsymbol{I}\)</span></li><li><span class="math inline">\(\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}=-\boldsymbol{a}^{\wedge}\)</span></li></ul><p><span class="math display">\[\begin{aligned}\sum_{n=0}^{\infty} \frac{1}{(n+1) !}\left(\phi^{\wedge}\right)^{n} &amp;=I+\frac{1}{2 !} \theta \boldsymbol{a}^{\wedge}+\frac{1}{3 !} \theta^{2}\left(\boldsymbol{a}^{\wedge}\right)^{2}+\frac{1}{4 !} \theta^{3}\left(\boldsymbol{a}^{\wedge}\right)^{3}+\frac{1}{5 !} \theta^{4}\left(\boldsymbol{a}^{\wedge}\right)^{4} \ldots \\&amp;=\frac{1}{\theta}\left(\frac{1}{2 !} \theta^{2}-\frac{1}{4 !} \theta^{4}+\cdots\right)\left(\boldsymbol{a}^{\wedge}\right)+\frac{1}{\theta}\left(\frac{1}{3 !} \theta^{3}-\frac{1}{5!} \theta^{5}+\cdots\right)\left(\boldsymbol{a}^{\wedge}\right)^{2}+\boldsymbol{I} \\&amp;=\frac{1}{\theta}(1-\cos \theta)\left(\boldsymbol{a}^{\wedge}\right)+\frac{\theta-\sin \theta}{\theta}\left(\boldsymbol{a} \boldsymbol{a}^{T}-\boldsymbol{I}\right)+\boldsymbol{I} \\&amp;= \frac{\sin \theta}{\theta} \boldsymbol{I}+\left(1-\frac{\sin \theta}{\theta}\right) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T} }+\frac{1-\cos \theta}{\theta} \boldsymbol{a}^{\wedge} {=} \boldsymbol{J}\end{aligned}\]</span></p><p>证毕。</p><h3 id="伴随">伴随</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171931993.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171931993.png" srcset="data:image/png;base64,666" alt="image-20201202171931993" style="zoom:67%;" /></p><p><code>证明</code></p><p>​ 对于任意的旋转矩阵<span class="math inline">\(\mathbf U\)</span>,以及向量<span class="math inline">\(\mathbf{a,b}\)</span>有： <span class="math display">\[( \mathbf{Ua}) \times( \mathbf{Ub})=\mathbf U(\mathbf{a} \times \mathbf{b})\]</span> ​ 因此有： <span class="math display">\[\begin{aligned}\boldsymbol{(R p)^{\wedge}v} &amp;= \boldsymbol{R  p \times v }\\&amp; = \boldsymbol{R  p \times (RR^Tv) } \\&amp; = \boldsymbol{R (p\times (R^Tv))}\\&amp; = \boldsymbol{Rp^{\wedge}R^Tv} \end{aligned}\tag{1}\]</span> ​ 又由于： <span class="math display">\[\begin{aligned}e^{\left(T^{-1} A T\right)} &amp;=E+\sum_{k=1}^{\infty} \frac{\left(T^{-1} A T\right)^{k} }{k !} \\&amp;=E+\sum_{k=1}^{\infty} \frac{T^{-1} A^{k} T}{k !} \\&amp;=E+T^{-1}\left(\sum_{k=1}^{\infty} \frac{A^{k} }{k !}\right) T \\&amp;=T^{-1}\left(e^{A}\right) T\end{aligned}\]</span> ​ 因此对(1)式两边取指数有： <span class="math display">\[\boldsymbol{R} \exp \left(\boldsymbol{p}^{\wedge}\right) \boldsymbol{R}^{\mathrm{T} }=\exp \left((\boldsymbol{R} \boldsymbol{p})^{\wedge}\right)\]</span> ​ 得证。</p><blockquote><p><a href="https://math.stackexchange.com/questions/2190603/derivation-of-adjoint-for-so3">Derivation of Adjoint for SO(3)</a></p><p><a href="https://wenku.baidu.com/view/f3bd3477f18583d0496459f4.html">矩阵指数函数的性质与计算-学士学位论文-P15</a></p></blockquote><h3 id="轨迹的描绘">轨迹的描绘</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171946056.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171946056.png" srcset="data:image/png;base64,666" alt="image-20201202171946056" style="zoom:67%;" /></p><p>1、</p><p>​ 机器人的运动轨迹<span class="math inline">\(T_{W C}\)</span>是机器人坐标系相对于世界坐标系的位姿，其包含两个旋转部分和平移部分。</p><p>​ 其中平移部分<span class="math inline">\(t_{wc}\)</span>是从<strong>世界坐标系原点</strong>指向<strong>机器人坐标系原点</strong>的向量，在世界坐标系下的取值；其值等价于机器人坐标系原点在世界坐标系下的取值，即<span class="math inline">\(\boldsymbol t_{wc}\)</span>是机器人坐标系原点在世界坐标系下的坐标。</p><hr /><p>2、</p><p>​ 见<a href="https://github.com/Divenire1998/vSLAM14_Practice/tree/master/ch3-%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0">Github</a>文件。</p><h3 id="轨迹的误差">轨迹的误差</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202172029228.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202172029228.png" srcset="data:image/png;base64,666" alt="image-20201202172029228" style="zoom:67%;" /></p><p>​ 见<a href="https://github.com/Divenire1998/vSLAM14_Practice/tree/master/ch3-%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0">Github</a>文件。</p><h2 id="课后习题">课后习题</h2><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202170003497.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202170003497.png" srcset="data:image/png;base64,666" alt="image-20201202170003497" /><figcaption>image-20201202170003497</figcaption></figure><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202170057407.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202170057407.png" srcset="data:image/png;base64,666" alt="image-20201202170057407" /><figcaption>image-20201202170057407</figcaption></figure><h3 id="section">1、</h3><p>​ <img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220618574.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220618574.png" srcset="data:image/png;base64,666" alt="image-20201208220618574" /></p><h3 id="section-1">2.</h3><p>​ 深蓝的课后习题-&gt;验证向量叉乘的李代数性质</p><h3 id="section-2">3.</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220644357.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220644357.png" srcset="data:image/png;base64,666" alt="image-20201208220644357" /><figcaption>image-20201208220644357</figcaption></figure><h3 id="section-3">4.</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220718657.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208220718657.png" srcset="data:image/png;base64,666" alt="image-20201208220718657" /><figcaption>image-20201208220718657</figcaption></figure><h3 id="section-4">5&amp;6.</h3><p>​ 深蓝课后习题-&gt;伴随</p><h3 id="section-5">7.</h3><p>1、</p><p>​ 对<span class="math inline">\(R\)</span>求取一次扰动<span class="math inline">\(\triangle R\)</span>，查看结果相对于扰动的变化率。设右扰动<span class="math inline">\(\triangle R\)</span>对应的李代数为<span class="math inline">\(\varphi\)</span>.</p><p><span class="math display">\[\begin{aligned}\frac{\partial(\mathbf{R} \mathbf{p})}{\partial \varphi} &amp;=\lim _{\varphi \rightarrow 0} \frac{\mathbf{R} \exp \left(\varphi^{\wedge}\right) \mathbf{p}-\mathbf{R} \mathbf{p} }{\varphi} \\&amp;=\lim _{\varphi \rightarrow 0} \frac{\mathbf{R}\left(\mathbf{I}+\varphi^{\wedge}\right) \mathbf{p}-\mathbf{R} \mathbf{p} }{\varphi} \\&amp;=\lim _{\varphi \rightarrow \mathbf{0} } \frac{\mathbf{R} \varphi^{\wedge} \mathbf{p} }{\varphi}=\lim _{\varphi \rightarrow 0} \frac{-\mathbf{R} \mathbf{p}^{\wedge} \varphi}{\varphi}=-\mathbf{R} \mathbf{p}^{\wedge}\end{aligned}\]</span></p><hr /><p>2、</p><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208215440419.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201208215440419.png" srcset="data:image/png;base64,666" /></p><h3 id="section-6">8.</h3><p><code>FIND_PACKAGE( &lt;name&gt; [version] [EXACT] [QUIET] [NO_MODULE] [ [ REQUIRED | COMPONENTS ] [ componets... ] ] )</code></p><p>​ 比较常用的参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">version参数</span><br><span class="line"></span><br><span class="line">需要一个版本号，它是正在查找的包应该兼容的版本号（格式是major[.minor[.patch[.tweak]]]）。</span><br><span class="line"></span><br><span class="line">EXACT选项</span><br><span class="line"></span><br><span class="line">要求版本号必须精确匹配。如果在find-module内部对该命令的递归调用没有给定[version]参数，那么[version]和EXACT选项会自动地从外部调用前向继承。对版本的支持目前只存在于包和包之间（详见下文）。</span><br><span class="line"></span><br><span class="line">QUIET 参数：</span><br><span class="line"></span><br><span class="line">会禁掉包没有被发现时的警告信息。对应于Find&lt;name&gt;.cmake模块中的 NAME_FIND_QUIETLY。</span><br><span class="line"></span><br><span class="line">REQUIRED 参数</span><br><span class="line"></span><br><span class="line">其含义是指是否是工程必须的，表示如果报没有找到的话，cmake的过程会终止，并输出警告信息。对应于Find&lt;name&gt;.cmake模块中的 NAME_FIND_REQUIRED 变量。</span><br><span class="line"></span><br><span class="line">COMPONENTS参数</span><br><span class="line"></span><br><span class="line">在REQUIRED选项之后，或者如果没有指定REQUIRED选项但是指定了COMPONENTS选项，在它们的后面可以列出一些与包相关（依赖）的部件清单（components list）</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">FIND_PACKAGE( libdb_cxx REQUIRED)</span><br><span class="line"></span><br><span class="line">这条命令执行后，CMake 会到变量 CMAKE_MODULE_PATH 指示的目录中查找文件 Findlibdb_cxx.cmake 并执行。</span><br></pre></td></tr></table></figure><p>​ 命令<strong>find_package</strong>共有两种工作模式：模型模式和配置模式。</p><ul><li>指令模式</li></ul><p><strong><code>find_package()</code> 命令会在模块路径中寻找 Find<name>.cmake</strong> ，<strong>这是查找库的一个典型方式。首先CMake查看<code>$&#123;CMAKE_MODULE_PATH&#125;</code> 中的所有目录，然后再查看它自己的模块目录 <CMAKE_ROOT>/share/cmake-x.y/Modules/ 。</strong></p><ul><li>配置模式</li></ul><p>**配置模式试图查找一个由待查找的包提供的配置文件的位置。包含该文件的路径会被存储在一个名为<package>_DIR的条目李,如果在上述那些目录中没找到这样的文件，会寻找 <Name>Config.cmake 或者 <lower-case-name>-config.cmake ，它们是假定库会安装的文件（但是目前还没有多少库会安装它们）。不做检查，直接包含安装的库的固定值。**</p><h2 id="参考">参考</h2><p><a href="https://blog.csdn.net/bytxl/article/details/50637277#">find_package与CMake如何查找链接库详解</a></p><p><a href="https://blog.csdn.net/haluoluo211/article/details/80559341">cmake教程4(find_package使用)</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
          <category> 14讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ch2-三维空间的刚体运动</title>
      <link href="2020/11/30/SLAM/14%E8%AE%B2/ch2-%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"/>
      <url>2020/11/30/SLAM/14%E8%AE%B2/ch2-%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>视觉SLAM14讲的课后习题以及深蓝的习题解答。</p><p>本节对应十四讲中的Ch3.</p><a id="more"></a><h2 id="深蓝的课后习题">深蓝的课后习题</h2><h3 id="熟悉-eigen-矩阵运算">熟悉 Eigen 矩阵运算</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171241674.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171241674.png" srcset="data:image/png;base64,666" alt="image-20201202171241674" style="zoom:67%;" /></p><p><strong>一、</strong></p><p>​ 由于<span class="math inline">\(A\)</span>是方阵，因此<span class="math inline">\(Ax = b\)</span>有唯一解的的充分必要条件为：矩阵<span class="math inline">\(A\)</span>的行列式<span class="math inline">\(d=|A|\neq0\)</span>(<strong>克拉默法则</strong>)。</p><p>​ 从秩的角度来说有唯一解的条件是<span class="math inline">\(Rank(A,b) = Rank(A)=n\)</span>。</p><p><strong>二、</strong></p><p>​ 利用线性方程组的初等行变换进行消元、化简。对于<span class="math inline">\(Ax=b\)</span>其核心思想是把A转换成一个三角矩阵，然后再进行正向代入法，或反向代入法求解。</p><p><strong>三、</strong></p><p>​ 对于矩阵<span class="math inline">\(A \in \mathbb{R}^{m \times n}, m \geq n\)</span>，其可被分解为<span class="math inline">\(A=QR\)</span>,其中：</p><ul><li><span class="math inline">\(Q \in \mathbb{R}^{m \times m}\)</span> 是正交矩阵</li><li><span class="math inline">\(R \equiv\left[\begin{array}{l}\hat{R} \\ 0\end{array}\right] \in \mathbb{R}^{m \times n}\)</span></li><li><span class="math inline">\(\hat{R} \in \mathbb{R}^{n \times n}\)</span> 是上三角矩阵</li></ul><p>其基本原理为<strong>格拉姆-施密特正交化</strong>。</p><p><code>证明：</code></p><p>定义向量的投影： <span class="math display">\[   \operatorname{proj}_{\mathbf{u}} \mathbf{a}=\frac{\langle\mathbf{u}, \mathbf{a}\rangle}{\langle\mathbf{u}, \mathbf{u}\rangle} \mathbf{u}\]</span></p><p>其中<span class="math inline">\({\langle\mathbf{u}, \mathbf{a}\rangle}\)</span>为向量的内积。</p><p>对于任意实方阵<span class="math inline">\(\mathbf{A}=(\mathbf{a_1},\mathbf{a_2},\ldots,\mathbf{a_n})\)</span>,对其列向量进行Gram-Schmidt正交化可得一组正交基<span class="math inline">\(\mathbf{Q}=(\mathbf{e_1},\mathbf{e_2},\ldots,\mathbf{e_n})\)</span>。</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/v2-db2b70e829ba299df005879b06165099_720w.jpg" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/v2-db2b70e829ba299df005879b06165099_720w.jpg" srcset="data:image/png;base64,666" alt="参考图" /><figcaption>参考图</figcaption></figure><p>​ 因此进行正交化有： <span class="math display">\[   \begin{array}{l}   \mathbf{u}_{1}=\mathbf{a}_{1} \\   \mathbf{u}_{2}=\mathbf{a}_{2}-\operatorname{proj}_{\mathbf{u}_{1}} \mathbf{a}_{2} \\   \mathbf{u}_{3}=\mathbf{a}_{3}-\operatorname{proj}_{\mathbf{u}_{1}} \mathbf{a}_{3}-\operatorname{proj}_{\mathbf{u}_{2}} \mathbf{a}_{3} \\   \vdots \\   \mathbf{u}_{k}=\mathbf{a}_{k}-\sum_{j=1}^{k-1} \operatorname{proj}_{\mathbf{u}_{j}} \mathbf{a}_{k}   \end{array}\]</span> ​ 单位化可得： <span class="math display">\[   \begin{aligned}   \mathbf{e}_{1} &amp;=\frac{\mathbf{u}_{1}}{\left\|\mathbf{u}_{1}\right\|} \\   \mathbf{e}_{2} &amp;=\frac{\mathbf{u}_{2}}{\left\|\mathbf{u}_{2}\right\|} \\   \mathbf{e}_{3} &amp;=\frac{\mathbf{u}_{3}}{\left\|\mathbf{u}_{3}\right\|} \\   &amp; \vdots \\   \mathbf{e}_{k} &amp;=\frac{\mathbf{u}_{k}}{\left\|\mathbf{u}_{k}\right\|}   \end{aligned}\]</span> ​ 此时方阵<span class="math inline">\(\mathbf{A}=(\mathbf{a_1},\mathbf{a_2},\ldots,\mathbf{a_n})\)</span>可表示为： <span class="math display">\[   \begin{aligned}   \mathbf{a}_{1} &amp;=\left\langle\mathbf{e}_{1}, \mathbf{a}_{1}\right\rangle \mathbf{e}_{1} \\   \mathbf{a}_{2} &amp;=\left\langle\mathbf{e}_{1}, \mathbf{a}_{2}\right\rangle \mathbf{e}_{1}+\left\langle\mathbf{e}_{2}, \mathbf{a}_{2}\right\rangle \mathbf{e}_{2} \\   \mathbf{a}_{3} &amp;=\left\langle\mathbf{e}_{1}, \mathbf{a}_{3}\right\rangle \mathbf{e}_{1}+\left\langle\mathbf{e}_{2}, \mathbf{a}_{3}\right\rangle \mathbf{e}_{2}+\left\langle\mathbf{e}_{3}, \mathbf{a}_{3}\right\rangle \mathbf{e}_{3} \\   &amp;: \\   \mathbf{a}_{k} &amp;=\sum_{j=1}^{k}\left\langle\mathbf{e}_{j}, \mathbf{a}_{k}\right\rangle \mathbf{e}_{j}   \end{aligned}\]</span> ​ 令： <span class="math display">\[   R=\left(\begin{array}{cccc}   \left\langle\mathbf{e}_{1}, \mathbf{a}_{1}\right\rangle &amp; \left\langle\mathbf{e}_{1}, \mathbf{a}_{2}\right\rangle &amp; \left\langle\mathbf{e}_{1}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   0 &amp; \left\langle\mathbf{e}_{2}, \mathbf{a}_{2}\right\rangle &amp; \left\langle\mathbf{e}_{2}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   0 &amp; 0 &amp; \left\langle\mathbf{e}_{3}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   \vdots &amp; \vdots &amp; \vdots &amp; \ddots   \end{array}\right)\]</span> ​ 因此有： <span class="math display">\[   \mathbf{A} = \mathbf{QR}=(\mathbf{e_1},\mathbf{e_2},\ldots,\mathbf{e_n})\left(\begin{array}{cccc}   \left\langle\mathbf{e}_{1}, \mathbf{a}_{1}\right\rangle &amp; \left\langle\mathbf{e}_{1}, \mathbf{a}_{2}\right\rangle &amp; \left\langle\mathbf{e}_{1}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   0 &amp; \left\langle\mathbf{e}_{2}, \mathbf{a}_{2}\right\rangle &amp; \left\langle\mathbf{e}_{2}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   0 &amp; 0 &amp; \left\langle\mathbf{e}_{3}, \mathbf{a}_{3}\right\rangle &amp; \ldots \\   \vdots &amp; \vdots &amp; \vdots &amp; \ddots   \end{array}\right)=(\mathbf{a_1},\mathbf{a_2},\ldots,\mathbf{a_n}).\]</span> ​ <span class="math inline">\(\mathbf{A} = \mathbf{QR}\)</span>得证。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/76703543">格拉姆-施密特正交化--QR分解法的来源</a></p><p><a href="https://zhuanlan.zhihu.com/p/112327923">QR分解</a></p></blockquote><p><strong>四、</strong></p><p>对于对称正定矩阵<span class="math inline">\(A\)</span>，可以有<span class="math inline">\(A=L L^{T}\)</span>。其<strong>基本原理为LU分解</strong>。</p><p><code>证明：</code></p><p>对于对称正定矩阵而言，可通过高斯消元法，得到唯一的Doolittle分解<span class="math inline">\(A=LU\)</span>.</p><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201007105209884.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201007105209884.png" srcset="data:image/png;base64,666" alt="image-20201007105209884" style="zoom:50%;" /></p><p>将矩阵<span class="math inline">\(U\)</span>的对角线提出有，<span class="math inline">\(A=LD\overline{U}\)</span>,且<span class="math inline">\(A\)</span>为对称矩阵有<span class="math inline">\(LD\overline{U}=\overline{U^T}DL^T\)</span>,<strong>由分解的唯一性</strong>可得，<span class="math inline">\(\overline{U^T}=L\)</span>,可以得到<span class="math inline">\(A=LDL^T\)</span>. <span class="math display">\[U=\left[\begin{array}{ccccccccc}d_{1} &amp; &amp; &amp; &amp; \\&amp; d_{2} &amp; &amp; &amp; \\&amp; &amp; \ddots &amp; &amp; \\&amp; &amp; &amp; \ddots &amp; \\&amp; &amp; &amp; &amp; d_{n}\end{array}\right]\left[\begin{array}{ccccc}1 &amp; \frac{*}{d_{1}} &amp; \cdots &amp; \cdots &amp; \overline{d_{1}} \\&amp; 1 &amp; \frac{*}{d_{2}} &amp; \cdots &amp; \frac{*}{d_{2}} \\&amp; &amp; 1 &amp; \cdots &amp; \cdots \\&amp; &amp; &amp; \ddots &amp; \cdots \\&amp; &amp; &amp; &amp; 1\end{array}\right]=D \overline{U}\]</span> 由<span class="math inline">\(D=\sqrt{D} \cdot \sqrt{D}\)</span>，<span class="math inline">\(A=L D L^{T}=L \sqrt{D} \sqrt{D} L^{T}=L \sqrt{D} \sqrt{D}^{T} L^{T}=L \sqrt{D}(L \sqrt{D})^{T}\)</span>，证毕。</p><blockquote><p><a href="https://blog.csdn.net/hanshihao1336295654/article/details/83422496">LU分解、LDLT分解、Cholesky分解</a></p></blockquote><p><strong>五、</strong></p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/1466148-20180926111703698-902236733.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/1466148-20180926111703698-902236733.png" srcset="data:image/png;base64,666" alt="img" /><figcaption>img</figcaption></figure><p>源代码见<a href="https://github.com/Divenire1998/vSLAM14_Practice">Github</a>的<code>eigenDataType.cpp</code>和<code>eigenSolveMatrix.cpp</code>.</p><blockquote><p>参考<a href="https://www.cnblogs.com/ymd12103410/p/9705792.html">Eigen解线性方程组</a></p></blockquote><h3 id="几何运算练习">几何运算练习</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171306589.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171306589.png" srcset="data:image/png;base64,666" alt="image-20201202171306589" style="zoom:67%;" /></p><p><code>答：</code></p><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201203111139165.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201203111139165.png" srcset="data:image/png;base64,666" alt="image-20201203111139165"  /></p><blockquote><p>源代码见<a href="https://github.com/Divenire1998/vSLAM14_Practice">Github</a>的coordinateTransform.cpp</p></blockquote><h3 id="旋转的表达">旋转的表达</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171328144.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171328144.png" srcset="data:image/png;base64,666" alt="image-20201202171328144" style="zoom:67%;" /></p><p><strong>一、</strong></p><p>已知<span class="math inline">\(\left(\boldsymbol e_{1}, \boldsymbol e_{2}\dots \boldsymbol e_{n}\right)\)</span>为<strong>标准正交基</strong>，坐标系<span class="math inline">\(\left(\boldsymbol e_{1}, \boldsymbol e_{2}\dots \boldsymbol e_{n}\right)\)</span>发生旋转后变为<span class="math inline">\(\left(\boldsymbol b_{1}, \boldsymbol b_{2}\dots \boldsymbol b_{n}\right)\)</span>,仍为<strong>标准正交基</strong>。</p><blockquote><p>基向量互相垂直就是正交基，每个基向量的模为1就是标准正交基。</p></blockquote><p>则旋转前后同一点的坐标可表示为 <span class="math display">\[   \left[\boldsymbol{e}_{1}, \boldsymbol{e}_{2},\dots \boldsymbol{e}_{n}\right]   \left[\begin{array}{c}   x_{1} \\   x_{2} \\   \vdots     \\   x_{n}   \end{array}\right]=   \left[{b}_{1}, {b}_{2},\dots {b}_{n}\right]   \left[\begin{array}{c}   y_{1} \\   y_{2} \\   \vdots     \\   y_{n}   \end{array}\right]\]</span></p><p><span class="math display">\[\left[\begin{array}{c}   x_{1} \\   x_{2} \\   \vdots     \\   x_{n}   \end{array}\right]=   \left[\begin{array}{ccc}   e_{1}^{T} b_{1}  &amp;\dots &amp; e_{1}^{T} b_{n} \\   \vdots           &amp;\ddots&amp; \vdots \\   e_{n}^{T} b_{1}  &amp;\dots &amp; e_{n}^{T} b_{n}   \end{array}\right]   \left[\begin{array}{c}   y_{1} \\   y_{2} \\   \vdots     \\   y_{n}   \end{array}\right]=    R \boldsymbol{y}\]</span></p><p>则有：</p><p><span class="math display">\[   R^{T}R =   \left[\begin{array}{ccc}   b_{1}^{T} e_{1}  &amp;\dots &amp; b_{n}^{T} e_{1} \\   \vdots           &amp;\ddots&amp; \vdots \\   b_{1}^{T} e_{n}  &amp;\dots &amp; b_{n}^{T} e_{n}   \end{array}\right]   \left[\begin{array}{ccc}   e_{1}^{T} b_{1}  &amp;\dots &amp; e_{1}^{T} b_{n} \\   \vdots           &amp;\ddots&amp; \vdots \\   e_{n}^{T} b_{1}  &amp;\dots &amp; e_{n}^{T} b_{n}   \end{array}\right]\]</span></p><p>对于对角线上的元素有：</p><p><span class="math display">\[\begin{aligned}R^{T}R(i,i)  &amp;= b_{i}^{T} [\sum_{j=1}^n e_{j}e_{j}^{T}]b_{i}\\&amp;= b_{i}^{T} E b_{i}=1\end{aligned}\]</span></p><p>非对角线上的元素有： <span class="math display">\[\begin{aligned}R^{T}R(i,j)  &amp;= b_{i}^{T} [\sum_{k=1}^n e_{k}e_{k}^{T}]b_{j}\\&amp;= b_{i}^{T} E b_{j}=0\end{aligned}\]</span></p><p>因此<span class="math inline">\(R^{T}R =E\)</span>.</p><p>上述公式表明，旋转矩阵<span class="math inline">\(R\)</span>把n维空间中的一组标准正交基转化成另一组标准正交基,将两组标准正交基分别用矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>表示。</p><p>有<span class="math inline">\(RA=B\)</span>，且<span class="math inline">\(det(A) = det(B)=1\)</span>,因此<span class="math inline">\(det(R) = 1\)</span>.</p><p>证毕。</p><p><strong>二、</strong></p><p><span class="math inline">\(dim(\varepsilon) = 1, dim(\eta) = 3\)</span></p><p><strong>三、</strong></p><p>由教材P57-3.24式可知： <span class="math display">\[   q_{1} q_{2}=\left[\begin{array}{c}   \eta_{1} \varepsilon_{2}+\eta_{2} \varepsilon_{1}+\varepsilon_{1} × \varepsilon_{2} \\   \eta_{1} \eta_{2}-\varepsilon_{1}^{T} \varepsilon_{2}   \end{array}\right]\]</span></p><p><span class="math display">\[   q_{1}^{+} q_{2}=\left[\begin{array}{cc}   \eta_{1} 1+\varepsilon_{1}^{×} &amp; \varepsilon_{1} \\   -\varepsilon_{1}^{T} &amp; \eta_{1}   \end{array}\right]\left[\begin{array}{c}   \varepsilon_{2} \\   \eta_{2}   \end{array}\right]=\left[\begin{array}{c}   \varepsilon_{1} \eta_{2}+\left(\eta_{1}+\varepsilon_{1}^{×}\right) \varepsilon_{2} \\   \eta_{1} \eta_{2}-\varepsilon_{1}^{T} \varepsilon_{2}   \end{array}\right]=\left[\begin{array}{c}   \eta_{2} \varepsilon_{1}+\eta_{1} \varepsilon_{2}+\varepsilon_{1}× \varepsilon_{2} \\   \eta_{1} \eta_{2}-\varepsilon_{1}^{T} \varepsilon_{2}   \end{array}\right]=q_{1}  q_{2}\]</span></p><p><span class="math display">\[   q_{2}^{\oplus} q_{1}=\left[\begin{array}{cc}   \eta_{2} 1 - \varepsilon_{2}^{×} &amp; \varepsilon_{2} \\   -\varepsilon_{2}^{T} &amp; \eta_{2}   \end{array}\right]\left[\begin{array}{c}   \varepsilon_{1} \\   \eta_{1}   \end{array}\right]=   \left[\begin{array}{c}   \varepsilon_{1} \eta_{2}+\left(\eta_{1}-\varepsilon_{2}^{×}\right) \varepsilon_{1} \\   \eta_{1} \eta_{2}-\varepsilon_{1}^{T} \varepsilon_{2}   \end{array}\right]=\left[\begin{array}{c}   \eta_{2} \varepsilon_{1}+\eta_{1} \varepsilon_{2}+\varepsilon_{1}× \varepsilon_{2} \\   \eta_{1} \eta_{2}-\varepsilon_{1}^{T} \varepsilon_{2}   \end{array}\right]=q_{1}q_{2}\]</span></p><p>证毕。</p><h3 id="罗德里格斯公式的证明">罗德里格斯公式的证明</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171358307.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171358307.png" srcset="data:image/png;base64,666" alt="image-20201202171358307" style="zoom:67%;" /></p><p><code>证明:</code></p><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201007190641899.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201007190641899.png" srcset="data:image/png;base64,666" alt="image-20201007190641899" style="zoom: 67%;" /></p><p>以上图为例子，矢量<span class="math inline">\(\boldsymbol r\)</span>绕着另一单位矢量<span class="math inline">\(\boldsymbol u\)</span> 转动角度<span class="math inline">\(\phi\)</span>，得到矢量<span class="math inline">\(\boldsymbol r’\)</span>。 <span class="math display">\[\overline{O^{\prime} B}=\boldsymbol{u} \times \boldsymbol{r}\]</span> 将矢量<span class="math inline">\(\boldsymbol r\)</span>分解为平行转轴与垂直转轴的分量，有：$r =r_{|}+r_{} $ <span class="math display">\[\begin{aligned}\boldsymbol r_{\|} &amp;=(\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u} \\\boldsymbol r_{\perp}&amp;=\boldsymbol r - \boldsymbol r_{\|}=\boldsymbol r -(\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u}\end{aligned}\]</span> 同理，对转动后的矢量进行分解与相似三角形原理有：<span class="math inline">\(\boldsymbol r^{\prime}=\boldsymbol r_{\|}^{\prime}+\boldsymbol r_{\perp}^{\prime}\)</span> <span class="math display">\[\boldsymbol r_{\|}^{\prime} =\boldsymbol r_{\|}  \\\]</span> <span class="math display">\[\begin{aligned}\boldsymbol r_{\perp}^{\prime} &amp;=\overline{O^{\prime} A} \cos \phi+\overline{O^{\prime} B} \sin \phi \\&amp;=[\boldsymbol r -(\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u}]  \cos \phi + \boldsymbol u \times \boldsymbol r \sin \phi\end{aligned}\]</span></p><p>代入可得： <span class="math display">\[\begin{aligned}r^{\prime} &amp;=\boldsymbol r \cos \phi -(\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u}  \cos \phi + \boldsymbol u \times \boldsymbol r \sin \phi\end{aligned}\]</span> 对<span class="math inline">\((\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u}\)</span>化简有： <span class="math display">\[(\boldsymbol r \cdot \boldsymbol{u}) \boldsymbol{u}=\boldsymbol{u}(\boldsymbol r \cdot \boldsymbol{u})=\boldsymbol{u} \boldsymbol{u^T}\boldsymbol r\]</span> 因此： <span class="math display">\[\begin{aligned}r^{\prime} &amp;=\boldsymbol r \cos \phi -\boldsymbol{u} \boldsymbol{u^T}\boldsymbol r  \cos \phi + \boldsymbol u \times \boldsymbol r \sin \phi \\&amp;=[ \cos \phi\boldsymbol I - \cos \phi\boldsymbol{u} \boldsymbol{u^T}   + \sin \phi\boldsymbol u \times  ]\boldsymbol r\\&amp;=\boldsymbol R \boldsymbol r\end{aligned}\]</span> 得证。</p><blockquote><p><a href="https://www.cnblogs.com/jingrui/p/9712461.html">参考</a></p></blockquote><h3 id="四元数运算性质的验证">四元数运算性质的验证</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171427022.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171427022.png" srcset="data:image/png;base64,666" alt="image-20201202171427022" style="zoom:67%;" /></p><p>​ <strong>本题主要是使用四元数进行旋转变换时候的代数关系原理以及与旋转矩阵之间的转换。</strong></p><p><code>证明:</code></p><p><strong>一、</strong></p><p>​ 设<span class="math inline">\(\boldsymbol p=(0,\boldsymbol v)\)</span>,旋转四元数<span class="math inline">\(\boldsymbol q = (\eta, \boldsymbol\varepsilon)\)</span>,则<span class="math inline">\(\boldsymbol q^{-1} = (\eta, -\boldsymbol\varepsilon)\)</span>。 <span class="math display">\[\boldsymbol p&#39;=\left[\begin{array}{c}\eta \\\boldsymbol  \varepsilon\end{array}\right]\left[\begin{array}{c}0 \\\boldsymbol  v\end{array}\right]\left[\begin{array}{c}\eta \\-\boldsymbol  \varepsilon\end{array}\right]=\left[\begin{array}{c}\eta \boldsymbol v +  \boldsymbol \varepsilon ×\boldsymbol v \\-\boldsymbol \varepsilon^{T} \boldsymbol v\end{array}\right]\left[\begin{array}{c}\eta \\-\boldsymbol  \varepsilon\end{array}\right]\]</span> ​ 其结果的实部为$v^{T} -^{T} v =0 $.因此旋转后的点为虚四元数。</p><p><strong>二、</strong></p><p>​ 由题意： <span class="math display">\[\begin{aligned}p^{\prime} &amp;=q p q^{-1} \\&amp;=q^{+} p^{+} q^{-1} \\&amp;=q^{+} q^{-1^{\oplus}} p \\\therefore Q &amp;=q^{+} q^{-1^{\oplus}}\end{aligned}\]</span></p><p>​ 展开可得： <span class="math display">\[q^{+}=\left[\begin{array}{cc}   \eta+\epsilon^{\times} &amp; \varepsilon \\   -\varepsilon^{T} &amp; \eta   \end{array}\right]=\left[\begin{array}{cccc}   w &amp; -z &amp; y &amp; x \\   z &amp; w &amp; -x &amp; y \\   -y &amp; x &amp; w &amp; z \\   -x &amp; -y &amp; -z &amp; w   \end{array}\right]\]</span></p><p><span class="math display">\[   q^{-1^{\ominus}}=\left[\begin{array}{cc}   \eta 1-(-\varepsilon)^{\times} &amp; -\varepsilon \\   -(-\varepsilon)^{T} &amp; \eta   \end{array}\right] /\|q\|^{2}=\frac{1}{\|q\|^{2}} \cdot\left[\begin{array}{cc}   \eta 1+\varepsilon^{\times} &amp; -\varepsilon \\   \varepsilon^{T} &amp; \eta   \end{array}\right]=\frac{1}{\|q\|^{2}} \cdot\left[\begin{array}{cccc}   w &amp; -z &amp; y &amp; -x \\   z &amp; w &amp; -x &amp; -y \\   -y &amp; x &amp; w &amp; -z \\   x &amp; y &amp; z &amp; w   \end{array}\right]\]</span></p><p><span class="math display">\[\begin{aligned}   Q&amp;=q^{+} q^{-1^{\oplus}}\\   &amp;=   \frac{1}{\|q\|^{2}}   \left[\begin{array}{cccc}   w^{2}+x^{2}-y^{2}+z^{2} &amp; 2 x y-2 z w &amp; 2 w y+2 x z &amp; 0 \\   2 x y+2 z w &amp; w^{2}-x^{2}+y^{2}-z^{2} &amp; 2 y z-2 x w &amp; 0 \\   2 x z-2 y w &amp; 2 y z+2 x w &amp; w^{2}-x^{2}-y^{2}+z^{2} &amp; 0 \\   0 &amp; 0 &amp; 0 &amp; w^{2}+x^{2}+y^{2}+z^{2}   \end{array}\right] \end{aligned}\]</span></p><h3 id="熟悉-c11">熟悉 C++11</h3><p><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171520168.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202171520168.png" srcset="data:image/png;base64,666" alt="image-20201202171520168" style="zoom:67%;" /></p><p>​ <code>答案：</code></p><ul><li>在15行中，<code>vector&lt;A&gt; avec&#123;a1, a2, a3&#125;</code>使用列表进行vector对象的初始化。</li><li>在16行中，<code>[](const A&amp;a1, const A&amp;a2) &#123;return a1.index&lt;a2.index;&#125;</code>为匿名lambda 表达式，实现avec 数组排序从小到大输出。</li><li>在17行中，<code>for ( auto&amp; a: avec )</code> 包含了<code>auto自动类型推导</code>和<code>基于范围的for循环</code>.</li></ul><h2 id="课后习题">课后习题</h2><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202195446946.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202195446946.png" srcset="data:image/png;base64,666" alt="image-20201202195446946" /><figcaption>image-20201202195446946</figcaption></figure><h3 id="section">1.</h3><p>​ <a href="#旋转的表达">见深蓝的课后习题《旋转的表达-1》</a></p><h3 id="section-1">2.</h3><p>​ <a href="#罗德里格斯公式的证明">见深蓝的课后习题《罗德里格斯公式的证明》</a></p><h3 id="section-2">3.</h3><p>​ <a href="#四元数运算性质的验证">见深蓝的课后习题《四元数运算性质的验证》</a></p><h3 id="todo">4. Todo</h3><p>​ <a href="">各种旋转表示法总结</a></p><h3 id="section-3">5.</h3><p>​ 使用Block.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//提取矩阵的一部分的子矩阵，从一个很大的矩阵中，提取出右上角的2x2矩阵，然后赋值为I</span></span><br><span class="line">    <span class="comment">// 生成随机矩阵和随机向量</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 6</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, MATRIX_SIZE&gt; matrix_NN</span><br><span class="line">            = Eigen::MatrixXd::Random(MATRIX_SIZE, MATRIX_SIZE);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-------------习题-------------&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;matrix_NN&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    Method 1 位操作</span></span><br><span class="line"><span class="comment">//    for (int i = MATRIX_SIZE-2; i &lt; MATRIX_SIZE; i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = MATRIX_SIZE-2; j &lt; MATRIX_SIZE; j++)</span></span><br><span class="line"><span class="comment">//            matrix_NN(i,j) = 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    Method 2 块操作</span></span><br><span class="line">    matrix_NN.block&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">0</span>,<span class="number">4</span>) = Eigen::Matrix2d::Identity(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;matrix_NN&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>源代码见<a href="https://github.com/Divenire1998/vSLAM14_Practice">Github</a>的eigenDataType.cpp</p></blockquote><h3 id="section-4">6.</h3><p>​ <a href="#熟悉%20Eigen%20矩阵运算">见深蓝的课后习题《熟悉Eigen矩阵运算-5》</a></p><blockquote><p>源代码见<a href="https://github.com/Divenire1998/vSLAM14_Practice">Github</a>的eigenSolveMatrix.cpp</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
          <category> 14讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ch1-概述与预备知识</title>
      <link href="2020/11/29/SLAM/14%E8%AE%B2/ch1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>2020/11/29/SLAM/14%E8%AE%B2/ch1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>视觉SLAM14讲的课后习题以及深蓝的习题解答。</p><p>本节对应十四讲中的Ch1和Ch2.</p><a id="more"></a><h2 id="深蓝的课后习题">深蓝的课后习题</h2><h3 id="熟悉linux">熟悉Linux</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126123904656.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126123904656.png" srcset="data:image/png;base64,666" alt="熟悉Linux" /><figcaption>熟悉Linux</figcaption></figure><h4 id="如何在-ubuntu-中安装软件命令行界面它们通常被安装在什么地方">1. 如何在 Ubuntu 中安装软件(命令行界面)?它们通常被安装在什么地方?</h4><ol type="1"><li><p><code>apt</code>安装方式，从系统软件源获取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install packge-name</span><br><span class="line"><span class="comment"># 修复安装，如果遇到安装失败，或者报错可以尝试用这个命令</span></span><br><span class="line">sudo apt -f install packge-name</span><br></pre></td></tr></table></figure></li><li><p><code>deb</code>软件包安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.使用dpkg  不自动处理依赖</span><br><span class="line">sudo dpkg -i packge-name.deb</span><br><span class="line">sudo apt install -f</span><br><span class="line"></span><br><span class="line">2.gdebi 自动处理依赖</span><br><span class="line">sudo gdebi packge-name.deb</span><br></pre></td></tr></table></figure></li><li><p><code>rpm</code>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将rpm文件转为deb文件</span></span><br><span class="line">sudo alien packge-name.rpm</span><br><span class="line"><span class="comment"># dpkg命令安装</span></span><br><span class="line">sudo dpkg -i packge-name.deb</span><br></pre></td></tr></table></figure></li><li><p><code>其他</code>安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行解压后文件夹的安装文件</span><br><span class="line">sudo .&#x2F;软件名* </span><br></pre></td></tr></table></figure></li></ol><hr /><ol type="1"><li>安装后软件默认位置 /usr/share</li><li>可执行文件位置 /usr/bin</li><li>库文件位置 /usr/lib</li></ol><h4 id="linux-的环境变量是什么我如何定义新的环境变量">2. linux 的环境变量是什么?我如何定义新的环境变量?</h4><p>环境变量是用来指定系统运行环境的一些参数，比如我们使用命令的路径，系统颜色等。</p><blockquote><p>常见环境变量如下所示：</p><p>PATH：决定了shell将到哪些目录中寻找命令或程序</p><p>HOME：当前用户主目录</p><p>MAIL：是指当前用户的邮件存放目录。</p><p>SHELL：是指当前用户用的是哪种Shell。</p><p>HISTSIZE：是指保存历史命令记录的条数</p><p>LOGNAME：是指当前用户的登录名。</p><p>HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。</p><p>LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</p><p>PS1：是基本提示符，对于root用户是#，对于普通用户是$。</p><p>PS2：是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符修改成字符串“Hello,MyNewPrompt:)”。</p></blockquote><hr /><p>以环境变量PATH为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义新的变量/home/divenire/Gams</span><br><span class="line"><span class="built_in">export</span> PATH=/home/divenire/Gams:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>这种方式立即生效，但<strong>作用范围仅限当前终端</strong>，一旦当前终端关闭或在另一个终端中，则无效。</p><p>因此也可以选择<strong>修改环境变量配置文件</strong>。</p><blockquote><p>环境变量配置文件中主要是定义对系统操作环境生效的系统默认环境变量，如PATH等；PATH、HISTSIZE、PS1、HOSTNAME等环境变量写入对应的环境变量配置文件；</p></blockquote><p>以环境变量PATH为例，修改对应的用户级环境变量配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件末端加入</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/divenire/Gams:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#保存，更新</span></span><br><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure><h4 id="linux-根目录下面的目录结构是什么样的至少说出-3-个目录的用途">3. linux 根目录下面的目录结构是什么样的?至少说出 3 个目录的用途。</h4><p><code>tree -L 1</code>根目录下目录结构如图所示。</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200919173309565.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200919173309565.png" srcset="data:image/png;base64,666" alt="image-20200919173309565" /><figcaption>image-20200919173309565</figcaption></figure><hr /><p><strong>./media</strong> 挂载可移动介质(media)，诸如CD、数码相机等用于挂载可移动设备的临时目录</p><p><strong>./bin</strong> 重要的二进制 (binary) 应用程序,包含二进制文件，系统的所有用户使用的命令都在这个目录下。</p><p><strong>./etc</strong> 配置文件、启动脚本等(etc)包含所有程序所需的配置文件，也包含了用于启动/停止单个程序的启动和关闭shell脚本</p><h4 id="假设我要给-a.sh-加上可执行权限该输入什么命令">4. 假设我要给 a.sh 加上可执行权限,该输入什么命令?</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x a.sh</span><br></pre></td></tr></table></figure><h4 id="假设我要将-a.sh-文件的所有者改成-xiangxiang该输入什么命令">5. 假设我要将 a.sh 文件的所有者改成 xiang:xiang,该输入什么命令?</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  xiang:xiang  a.sh </span><br></pre></td></tr></table></figure><h3 id="slam文献阅读">SLAM文献阅读</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126123940729.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126123940729.png" srcset="data:image/png;base64,666" alt="SLAM文献阅读" /><figcaption>SLAM文献阅读</figcaption></figure><h4 id="slam-会在哪些场合中用到至少列举三个方向">1. SLAM 会在哪些场合中用到?至少列举三个方向。</h4><ul><li>三维重建，AR，VR</li><li>无人驾驶</li><li>移动机器人的自主导航与定位</li></ul><h4 id="slam-中定位与建图是什么关系为什么在定位的同时需要建图">2. SLAM 中定位与建图是什么关系?为什么在定位的同时需要建图?</h4><p>​ 定位与建图是相互耦合的关系，只有明确了当前所在的位置，才能建立出准确的地图地图，反之只有在拥有准确地图的情况下，才能够根据周围的环境准确的判断出自身所在的位置。</p><p>​ SLAM中采用上一个时刻的地图来估计此刻的位姿，并利用当前位姿更新地图，如此循环来解决定位与建图的问题。因此在定位的同时需要建地图。</p><h4 id="slam-发展历史如何我们可以将它划分成哪几个阶段">3. SLAM 发展历史如何?我们可以将它划分成哪几个阶段?</h4><ul><li><p>古典时代（1986-2004年）经典时代引入了SLAM的主要概率公式，包括基于扩展卡尔曼滤波器、RaoBlackwelled粒子滤波器和最大似然估计的方法 。</p></li><li><p>算法分析时代（2004-2015年）算法分析阶段研究了SLAM的基本性质，包括可观测性、收敛性和一致性 。</p></li><li><p>我们正在进入SLAM的第三个时代，即鲁棒感知时代。</p></li></ul><h4 id="列举三篇在-slam-领域的经典文献">4. 列举三篇在 SLAM 领域的经典文献。</h4><ul><li>ORB-SLAM2:Mur-Artal R , Tardos J D . ORB-SLAM2: An Open-Source SLAM System for Monocular,Stereo, and RGB-D Cameras[J]. IEEE Transactions on Robotics, 2017:1-8.</li><li>semi-direct visual odometry</li><li>Large-Scale Direct Monocular SLAM</li></ul><h3 id="cmake练习">CMake练习</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126124020051.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126124020051.png" srcset="data:image/png;base64,666" alt="image-20201126124020051" /><figcaption>image-20201126124020051</figcaption></figure><p>工程文件结构如下所示。</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920110302876.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920110302876.png" srcset="data:image/png;base64,666" alt="image-20200920110302876" /><figcaption>image-20200920110302876</figcaption></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HELLO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加可执行文件</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(sayhello  <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/useHello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加库 并链接</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED src/hello.cpp)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(sayhello <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="comment">#设置库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#install</span></span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span> LIBRARY DESTINATION /usr/local/lib)</span><br><span class="line"><span class="keyword">INSTALL</span>(FILES <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/hello.h DESTINATION /usr/local/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>运行截图</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111430221.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111430221.png" srcset="data:image/png;base64,666" alt="image-20200920111430221" /><figcaption>image-20200920111430221</figcaption></figure><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111531133.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111531133.png" srcset="data:image/png;base64,666" alt="image-20200920111531133" /><figcaption>image-20200920111531133</figcaption></figure><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111335182.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111335182.png" srcset="data:image/png;base64,666" alt="image-20200920111335182" /><figcaption>image-20200920111335182</figcaption></figure><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111556695.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920111556695.png" srcset="data:image/png;base64,666" alt="image-20200920111556695" /><figcaption>image-20200920111556695</figcaption></figure><h3 id="理解orbslam框架">理解ORBSLAM框架</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126124134268.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126124134268.png" srcset="data:image/png;base64,666" alt="image-20201126124134268" /><figcaption>image-20201126124134268</figcaption></figure><hr /><h4 id="a-orb-slam2-将编译出什么结果有几个库文件和可执行文件">(a) ORB-SLAM2 将编译出什么结果?有几个库文件和可执行文件?</h4><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920093332487.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920093332487.png" srcset="data:image/png;base64,666" alt="image-20200920093332487" /><figcaption>image-20200920093332487</figcaption></figure><ul><li>生成3个库文件</li></ul><ol type="1"><li><strong>lib/libORB_SLAM2.so</strong></li><li><strong>Thirdparty/g2o/lib /libg2o.so</strong></li><li><strong>Thirdparty/DBoW2/lib/libDBoW2.so</strong></li></ol><ul><li>6个可执行文件</li></ul><ol type="1"><li><strong>Examples/Monocular/mono_euroc</strong></li><li><strong>Examples/Monocular/mono_kitti</strong></li><li><strong>Examples/Monocular/mono_tum</strong></li><li><strong>Examples/RGB-D/rgbd_tum</strong></li><li><strong>Examples/Stereo/stereo_euroc</strong></li><li><strong>Examples/Stereo/stereo_kitti</strong></li></ol><h4 id="b-orb-slam2-中的-include-src-examples-三个文件夹中都含有什么内容">(b) ORB-SLAM2 中的 include, src, Examples 三个文件夹中都含有什么内容?</h4><ul><li>include文件夹中是ORB-SLAM2库的头文件;</li><li>src文件夹中是是ORB-SLAM2库的源文件；</li><li>Example文件夹中包含单目，RGBD，双目以及ROS的实例工程代码文件和相机参数文件，以及编译后的文件都保存在这儿。</li></ul><h4 id="c-orb-slam2-中的可执行文件链接到了哪些库它们的名字是什么">(c) ORB-SLAM2 中的可执行文件链接到了哪些库?它们的名字是什么?</h4><ul><li><p>lib/libORB_SLAM2.so</p><p>ORB-SLAM2的库。</p></li><li><p>Thirdparty/g2o/lib /libg2o.so</p><p>g2o优化库，为第三方库文件。</p></li><li><p>Thirdparty/DBoW2/lib/libDBoW2.so</p><p>DboW2回环检测库，为第三方库文件。</p></li></ul><h3 id="摄像头运行orb-slam">摄像头运行ORB-SLAM</h3><ul><li>CMakeLists 修改方案。在工程目录下的CMakeLists.txt末尾加入如下代码。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/myvideo)</span><br><span class="line"><span class="keyword">add_executable</span>(myvideo Examples/myvideo/myvideo.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myvideo <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(myslam Examples/myvideo/myslam.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myslam <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="使用电脑摄像头运行orb-slam">使用电脑摄像头运行ORB-SLAM</h4><p>运行截图如下。</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920151100860.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920151100860.png" srcset="data:image/png;base64,666" alt="image-20200920151100860" /><figcaption>image-20200920151100860</figcaption></figure><h4 id="使用视频运行orb-slam">使用视频运行ORB-SLAM</h4><p>运行截图如下</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920113608240.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20200920113608240.png" srcset="data:image/png;base64,666" alt="image-20200920113608240" /><figcaption>image-20200920113608240</figcaption></figure><h2 id="课后习题">课后习题</h2><h3 id="第一章">第一章</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202163749037.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201202163749037.png" srcset="data:image/png;base64,666" alt="image-20201202163749037" /><figcaption>image-20201202163749037</figcaption></figure><h4 id="section">1</h4><p>​ 对于<span class="math inline">\(A_{m*n}X=b\)</span></p><p>​ 有解的条件是：增广矩阵的秩 等于 系数矩阵的秩，既<span class="math inline">\(Rank(A,b) = Rank(A)\)</span>.</p><p>​ 有唯一解的条件是<span class="math inline">\(Rank(A,b) = Rank(A)=n\)</span></p><h4 id="section-1">3</h4><p>​ 在<strong>一维情况下</strong>，高斯概率密度函数表示为:</p><p><span class="math display">\[p\left(x \mid \mu, \sigma^{2}\right)=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp \left(-\frac{1}{2} \frac{(x-\mu)^{2}}{\sigma^{2}}\right)\]</span> ​ 其中 <span class="math inline">\(\mu\)</span> 称为均值 (mean), <span class="math inline">\(\sigma^{2}\)</span> 为方差 (variance), <span class="math inline">\(\sigma\)</span> 称为标准差 (standard deviation)。</p><p>​ <strong>多维变量</strong>的高斯分布如下 <span class="math display">\[p(x \mid \mu, \Sigma)=\frac{1}{\sqrt{(2 \pi)^{N} \operatorname{det} \Sigma}} \exp \left(-\frac{1}{2}(x-\mu)^{\mathrm{T}} \Sigma^{-1}(x-\mu)\right)\]</span> ​ 其中 <span class="math inline">\(\mu \in \mathbb{R}^{N}\)</span> 是均值, <span class="math inline">\(\Sigma \in \mathbb{R}^{N \times N}\)</span> 是协方差矩阵（<strong>对称正定矩阵</strong>）</p><h3 id="第二章">第二章</h3><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/IMG_20201202_164639.jpg" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/IMG_20201202_164639.jpg" srcset="data:image/png;base64,666" alt="IMG_20201202_164639" /><figcaption>IMG_20201202_164639</figcaption></figure><h4 id="nop">1 Nop</h4><h4 id="nop-1">2 Nop</h4><h4 id="section-2">6</h4><p>​ 会出现<strong>undefined reference</strong>错误；</p><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126202731716.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201126202731716.png" srcset="data:image/png;base64,666" alt="image-20201126202731716" /><figcaption>image-20201126202731716</figcaption></figure><h4 id="section-3">8</h4><p><code>lib</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">工程目录</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── inc</span><br><span class="line">│   └── libHelloSLAM.h</span><br><span class="line">├── install.sh</span><br><span class="line">└── src</span><br><span class="line">    └── libHelloSLAM.cpp</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明要求的 cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 声明一个 cmake 工程</span></span><br><span class="line"><span class="keyword">project</span>(hello)</span><br><span class="line"><span class="comment"># 设置编译模式</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Create a library</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># 动态库</span></span><br><span class="line"><span class="comment">#Generate the shared library from the library sources</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED </span><br><span class="line">    src/libHelloSLAM.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_include_directories</span>(hello</span><br><span class="line">    PUBLIC </span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/inc</span><br><span class="line">)</span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Install</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Library</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> may not work on windows</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS hello</span><br><span class="line">    LIBRARY DESTINATION lib)</span><br><span class="line"><span class="comment"># Header files</span></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/inc/ </span><br><span class="line">    DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><code>project</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#工程目录</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cmake_modules</span><br><span class="line">│   └── Findhello.cmake</span><br><span class="line">├── run.sh</span><br><span class="line">└── useHello.cpp</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMakeLists.txt</span></span><br><span class="line"><span class="comment"># 声明要求的 cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 声明一个 cmake 工程</span></span><br><span class="line"><span class="keyword">project</span>(HelloSlam)</span><br><span class="line"><span class="comment"># 设置编译模式</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules&quot;</span>)</span><br><span class="line"><span class="comment"># 寻找库文件</span></span><br><span class="line"><span class="keyword">find_package</span>(hello REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HELLO_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloSlam useHello.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>   <span class="variable">$&#123;HELLO_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;include dir:$&#123;HELLO_INCLUDE_DIR&#125;  lib dir:$&#123;HELLO_LIBRARY&#125; &quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Findhello.cmake</span></span><br><span class="line"><span class="comment"># 在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径</span></span><br><span class="line"><span class="comment"># Find the header files</span></span><br><span class="line"><span class="keyword">FIND_PATH</span>(HELLO_INCLUDE_DIR </span><br><span class="line">NAMES libHelloSLAM.h</span><br><span class="line">PATHS /usr/local/<span class="keyword">include</span></span><br><span class="line">      /usr/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Find lib </span></span><br><span class="line"><span class="keyword">FIND_LIBRARY</span>(HELLO_LIBRARY</span><br><span class="line">NAMES hello</span><br><span class="line">PATHS /usr/local/lib</span><br><span class="line">      /usr/lib</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> (HELLO_INCLUDE_DIR <span class="keyword">AND</span> HELLO_LIBRARY)</span><br><span class="line">    <span class="keyword">set</span>(HELLO_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">endif</span> (HELLO_INCLUDE_DIR <span class="keyword">AND</span> HELLO_LIBRARY)</span><br></pre></td></tr></table></figure><blockquote><p>工程文件见:<a href="https://github.com/Divenire1998/vSLAM14_Practice/tree/master/ch1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/Hello%20SLAM">Github</a></p></blockquote><h2 id="参考">参考</h2><blockquote><p><a href="https://blog.csdn.net/qq_32863631/article/details/76348963">linux中环境变量及环境变量配置文件详解</a></p><p><a href="https://blog.csdn.net/pengjunlee/article/details/81585726">Linux环境变量文件介绍</a></p><p><a href="https://www.cnblogs.com/yuzhaoblog/p/11225018.html">Linux添加新的环境变量</a></p><p><a href="https://www.cnblogs.com/panchanggui/p/12037230.html">Linux根目录下各个目录的用途及含义</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
          <category> 14讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM2环境配置</title>
      <link href="2020/11/28/SLAM/ORB-SLAM2/ORB-SLAM2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>2020/11/28/SLAM/ORB-SLAM2/ORB-SLAM2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>ORB-SLAM2的环境配置。</p><a id="more"></a><h2 id="eigen">EIGEN</h2><ul><li>卸载原有的Eigen版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看原有的Eiegn位置</span></span><br><span class="line">sudo updatedb  </span><br><span class="line">locate eigen3  </span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">sudo rm -rf /usr/include/eigen3</span><br><span class="line">sudo rm -rf /usr/lib/cmake/eigen3</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/include/eigen3</span><br><span class="line">sudo rm -rf /usr/share/doc/libeigen3-dev </span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/share/eigen3</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/share/pkgconfig/eigen3.pc /usr/share/pkgconfig/eigen3.pc /var/lib/dpkg/info/libeigen3-dev.list /var/lib/dpkg/info/libeigen3-dev.md5sums</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新查看Eiegn位置</span></span><br><span class="line">sudo updatedb  </span><br><span class="line">locate eigen3  </span><br></pre></td></tr></table></figure><ul><li>安装Eigen3.3.8</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># eigen安装默认的地址是：/usr/local/include里 ，我们在安装pangolin时，会在/usr/include 目录下进行搜索eigen，导致pangolin安装失败，通常我们复制一份在、usr/include上面命令可以解决:</span></span><br><span class="line"></span><br><span class="line">sudo cp -r /usr/<span class="built_in">local</span>/include/eigen3 /usr/include </span><br></pre></td></tr></table></figure><ul><li>修改FindEigen.Cmake文件，实现多版本共存</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_path</span>(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library</span><br><span class="line">PATHS</span><br><span class="line"><span class="comment"># 写eigen的路径</span></span><br><span class="line">/media/divenire/D/<span class="number">0</span>_Divenire/Workspace/LIB/EIGEN/eigen-<span class="number">3.3</span>.<span class="number">8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="opencv">OPENCV</h2><ul><li>OEPNCV 3.4.12 下载、安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时代理</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:12333&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:12333&quot;</span></span><br><span class="line"><span class="comment"># 使用wget</span></span><br><span class="line">wget opencv_address</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br><span class="line">cmake --build build -j12</span><br></pre></td></tr></table></figure><ul><li>修改CMakeList 指定OPENCV版本和路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置到自己的OPENCV路径</span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR <span class="string">&quot;/media/divenire/D/0_Divenire/Workspace/LIB/OPENCV/3.4.12/opencv-3.4.12/builds&quot;</span>)</span><br><span class="line">find_package(OpenCV  REQUIRED)</span><br></pre></td></tr></table></figure><h2 id="pangolin">PANGOLIN</h2><ul><li><p>下载PANGOLIN</p></li><li><p>编译</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br><span class="line">cmake --build build -j12</span><br></pre></td></tr></table></figure><ul><li>修改CMakeList 指定PANGOLIN版本和路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置到自己的PANGOLIN路径</span></span><br><span class="line"><span class="built_in">set</span>(Pangolin_DIR <span class="string">&quot;/media/divenire/D/0_Divenire/Workspace/LIB/Pangolin/build/src&quot;</span>)</span><br><span class="line">find_package(Pangolin REQUIRED)</span><br></pre></td></tr></table></figure><h2 id="orbslam2">ORBSLAM2</h2><h3 id="编译">编译</h3><p>最好分开编译，先编译第三方的文件夹的G2O那些库(修改编译第三方库的Cmake配置)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><h3 id="数据集">数据集</h3><ul><li>单目&amp;双目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压下载的数据集</span></span><br><span class="line"><span class="comment"># 把TUMX换成对应的相机参数设置</span></span><br><span class="line">./Examples/Monocular/mono_tum ./Vocabulary/ORBvoc.txt ./Examples/Monocular/TUMX.yaml &#123;数据集路径(解压后的文件夹)&#125;</span><br></pre></td></tr></table></figure><ul><li>RGB-D</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立关联</span></span><br><span class="line">python associate.py PATH_TO_SEQUENCE/rgb.txt PATH_TO_SEQUENCE/depth.txt &gt; associations.txt</span><br><span class="line"><span class="comment"># 把TUMX换成对应的相机参数设置</span></span><br><span class="line">./Examples/RGB-D/rgbd_tum Vocabulary/ORBvoc.txt Examples/RGB-D/TUMX.yaml PATH_TO_SEQUENCE_FOLDER ASSOCIATIONS_FILE</span><br></pre></td></tr></table></figure><h3 id="摄像头视频">摄像头&amp;视频</h3><p>CMakeLists 修改方案。在工程目录下的CMakeLists.txt末尾加入如下代码。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Examples/myvideo)</span><br><span class="line"><span class="keyword">add_executable</span>(myvideo Examples/myvideo/myvideo.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myvideo <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(myslam Examples/myvideo/myslam.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myslam <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>摄像头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Examples/myvideo/myslam ./Vocabulary/ORBvoc.txt ./Examples/myvideo/myslam.yaml</span><br></pre></td></tr></table></figure><ul><li>视频</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Examples/myvideo/myvideo ./Vocabulary/ORBvoc.txt ./Examples/myvideo/myvideo.yaml Examples/myvideo/myvideo.mp4</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://vision.in.tum.de/data/datasets/rgbd-dataset/tools">TUM工具-误差评估-关联</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
          <category> ORB-SLAM2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2020/11/19/%E6%B5%8B%E8%AF%95/"/>
      <url>2020/11/19/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试文章 <span class="math display">\[THIS \\ is \\a \\math \ expression\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Cate </category>
          
          <category> SubCate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非线性优化1--高斯牛顿法</title>
      <link href="2020/11/12/%E6%95%B0%E5%AD%A6/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%961%E2%80%94%E2%80%94%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
      <url>2020/11/12/%E6%95%B0%E5%AD%A6/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%961%E2%80%94%E2%80%94%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>高斯牛顿法的推导与应用实例。</p><a id="more"></a><h2 id="推导">推导</h2><p>​ 假设观测到 <span class="math inline">\(\mathrm{N}\)</span> 个数据点 <span class="math inline">\(\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \ldots,\left(x_{N}, y_{N}\right)\right\},\)</span> 其中 <span class="math inline">\(x \in \mathbb{R}^{M}\)</span> 。希望找到包含 <span class="math inline">\(\mathrm{M}\)</span> 个参数的非线性函数 <span class="math inline">\(f\left(x, a_{1}, a_{2}, \ldots, a_{M}\right),\)</span> 拟合上述N个数据点。</p><p>​ 为了方便书写, 记: <span class="math inline">\(\quad f_{1}(\mathbf{a})=f\left(x_{1}, a_{1}, \ldots a_{M}\right)_{\circ}\)</span> 则最小二乘的目标函数为: <span class="math display">\[\varepsilon(\mathbf{a})=\sum_{i=1}^{N}\left\|f_{i}(\mathbf{a})-y_{i}\right\|^{2} \tag{1}\]</span> ​ 我们需要找到 <span class="math inline">\(\mathbf{a}=\left[a_{1}, a_{2}, \ldots, a_{M}\right]^{T},\)</span> 使得(1) 的值最小。将 (1) 对 <span class="math inline">\(\mathbf{a}_{j}\)</span> 求导: <span class="math display">\[\frac{\partial \varepsilon(\mathbf{a})}{a_{j}}=\sum_{i=1}^{N} 2\left(f_{i}(\mathbf{a})-y_{i}\right) \cdot \frac{\partial f_{i}(\mathbf{a})}{\partial a_{j}} \tag{2}\]</span></p><p>​ 因此可得<span class="math inline">\(\varepsilon(\mathbf{a})\)</span>的梯度为：<span class="math inline">\(\nabla \varepsilon(\mathbf{a}) =\left[\frac{\partial \varepsilon(\mathbf{a})}{a_{1}}, \frac{\partial \varepsilon(\mathbf{a})}{a_{2}}, \ldots, \frac{\partial \varepsilon(\mathbf{a})}{a_{M}}\right]^{T}\)</span>.</p><p><span class="math display">\[\nabla \varepsilon(\mathbf{a}) = \left[\begin{array}{cccc}\frac{\partial f_{1}(\mathbf{a})}{\partial a_{1}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{1}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{1}} \\\frac{\partial f_{1}(\mathbf{a})}{\partial a_{2}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{2}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{2}} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\frac{\partial f_{1}(\mathbf{a})}{\partial a_{M}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{2}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{M}}\end{array}\right]\times\left[\begin{array}{cccc}f_{1}(\mathbf{a})-y_{1} \\f_{2}(\mathbf{a})-y_{2} \\\vdots \\f_{N}(\mathbf{a})-y_{N}\end{array}\right]\]</span></p><p>​ 且有：</p><p><span class="math display">\[\mathbf{J}_i = \left[\frac{\partial f_{i}(\mathbf{a})}{\partial a_{1}}, \frac{\partial f_{i}(\mathbf{a})}{\partial a_{2}}, \ldots, \frac{\partial f_{i}(\mathbf{a})}{\partial a_{M}}\right]^{T} \mathbf{r}=\left[\begin{array}{c}f_{1}(\mathbf{a})-y_{1} \\f_{2}(\mathbf{a})-y_{2} \\\vdots f_{N}(\mathbf{a})-y_{N}\end{array}\right]\\\]</span> <span class="math display">\[\mathbf{J} = \left[\begin{array}{cccc}\frac{\partial f_{1}(\mathbf{a})}{\partial a_{1}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{1}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{1}} \\\frac{\partial f_{1}(\mathbf{a})}{\partial a_{2}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{2}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{2}} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\frac{\partial f_{1}(\mathbf{a})}{\partial a_{M}} &amp; \frac{\partial f_{2}(\mathbf{a})}{\partial a_{2}} &amp; \cdots &amp; \frac{\partial f_{N}(\mathbf{a})}{\partial a_{M}}\end{array}\right] = \left[\mathbf{J}_1, \mathbf{J}_2, \ldots, \mathbf{J}_N\right]^{T}\\\]</span></p><p>​ 因此写成向量形式有： <span class="math display">\[\nabla \varepsilon(\mathbf{a})=2 \mathbf{J}^{}\left[\begin{array}{c}\left(f_{1}(\mathbf{a})-y_{1}\right) \\\vdots \\\left(f_{N}(\mathbf{a})-y_{N}\right)\end{array}\right]=2 \mathbf{J}^{} \cdot(\vec{f}(\mathbf{a})-\vec{y})\]</span> ​ <strong>根据迭代方法找到<span class="math inline">\(\mathbf{a}_{n+1}\)</span>使得上式等于0，因此有</strong>： <span class="math display">\[\begin{aligned}\nabla \varepsilon\left(\mathbf{a}_{n+1}\right) &amp;=2 \mathbf{J}^{}\left(\vec{f}\left(\mathbf{a}_{n+1}\right)-\vec{y}\right) \\&amp; \approx 2 \mathbf{J}^{}\left(\vec{f}\left(\mathbf{a}_{n}\right)+\mathbf{J}^{T} \cdot\left(\mathbf{a}_{n+1}-\mathbf{a}_{n}\right)-\vec{y}\right)=0\end{aligned}\]</span> ​ 对上式整理可得： <span class="math display">\[\mathbf{a}_{n+1}=\mathbf{a}_{n}-\left(\mathbf{JJ^{T}} \right)^{-1} \mathbf J \cdot \mathbf{r} \\\]</span> <span class="math display">\[\underbrace{\mathbf{JJ^{T}}}_{\mathbf H}\Delta \mathbf{a} = \underbrace{\mathbf J \cdot \mathbf{r}}_{\mathbf{g}} \tag{3}\]</span></p><p>​ 式(3)即是关于<span class="math inline">\(\Delta a\)</span>的线性方程组，成为<strong>增量方程</strong>。对比牛顿法，高斯牛顿法采用<span class="math inline">\(\mathbf{JJ^{T}}\)</span>作为<span class="math inline">\(\mathbf{H}\)</span>矩阵的近似，简化了海森矩阵的计算过程。同时将<span class="math inline">\(\mathbf{H}\)</span>矩阵展开后，可分解为各步<span class="math inline">\(\mathbf{J}_i\)</span>计算而得： <span class="math display">\[\mathbf H =\mathbf{JJ^{T}} = \sum_{i=1}^{N}\mathbf{J}_i\mathbf{J}_i^T\]</span></p><h2 id="步骤">步骤</h2><ol type="1"><li>给定初始值<span class="math inline">\(\mathbf a_0\)</span></li><li>对于第k次迭代，求解出当前的雅可比矩阵<span class="math inline">\(\mathbf J\)</span>以及残差<span class="math inline">\(\mathbf r\)</span>.</li><li>根据(3)式，求解增量方程<span class="math inline">\(\Delta \mathbf a\)</span></li><li>如果<span class="math inline">\(\Delta \mathbf a\)</span>足够小，则停止。否则继续迭代。</li></ol><h2 id="实例">实例</h2><figure><img src="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201112100800405.png" class="lazyload" data-srcset="https://tuchuang-1998.oss-accelerate.aliyuncs.com/Picgo/image-20201112100800405.png" srcset="data:image/png;base64,666" alt="图1" /><figcaption>图1</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始Gauss-Newton迭代</span></span><br><span class="line"><span class="keyword">int</span> iterations = <span class="number">100</span>;    <span class="comment">// 迭代次数</span></span><br><span class="line"><span class="keyword">double</span> cost = <span class="number">0</span>, lastCost = <span class="number">0</span>;  <span class="comment">// 本次迭代的cost和上一次迭代的cost</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> iter = <span class="number">0</span>; iter &lt; iterations; iter++) &#123;</span><br><span class="line"></span><br><span class="line">    Matrix3d H = Matrix3d::Zero();             <span class="comment">// Hessian = J^T J in Gauss-Newton</span></span><br><span class="line">    Vector3d b = Vector3d::Zero();             <span class="comment">// bias</span></span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> xi = x_data[i], yi = y_data[i];  <span class="comment">// 第i个数据点</span></span><br><span class="line">        <span class="comment">// start your code here</span></span><br><span class="line">        <span class="keyword">double</span> error = <span class="number">0</span>;   <span class="comment">// 第i个数据点的计算误差</span></span><br><span class="line">        error = yi - <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);; <span class="comment">// 填写计算error的表达式</span></span><br><span class="line">        Vector3d J; <span class="comment">// 雅可比矩阵</span></span><br><span class="line">        J[<span class="number">0</span>] = -xi * xi * <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/da</span></span><br><span class="line">        J[<span class="number">1</span>] = -xi * <span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/db</span></span><br><span class="line">        J[<span class="number">2</span>] = -<span class="built_in">exp</span>(ae * xi * xi + be * xi + ce);  <span class="comment">// de/dc</span></span><br><span class="line"></span><br><span class="line">        H += J * J.transpose(); <span class="comment">// GN近似的H</span></span><br><span class="line">        b += -error * J;</span><br><span class="line">        <span class="comment">// end your code here</span></span><br><span class="line"></span><br><span class="line">        cost += error * error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解线性方程 Hx=b，建议用ldlt</span></span><br><span class="line">    <span class="comment">// start your code here</span></span><br><span class="line">    Vector3d dx = H.ldlt().solve(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end your code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isnan(dx[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is nan!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter &gt; <span class="number">0</span> &amp;&amp; cost &gt; lastCost) &#123;</span><br><span class="line">        <span class="comment">// 误差增长了，说明近似的不够好</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost: &quot;</span> &lt;&lt; cost &lt;&lt; <span class="string">&quot;, last cost: &quot;</span> &lt;&lt; lastCost &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新abc估计值</span></span><br><span class="line">    ae += dx[<span class="number">0</span>];</span><br><span class="line">    be += dx[<span class="number">1</span>];</span><br><span class="line">    ce += dx[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    lastCost = cost;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;iter&lt;&lt;<span class="string">&quot;次迭代结果&quot;</span>&lt;&lt;<span class="string">&quot;    a:&quot;</span>&lt;&lt;ae&lt;&lt;<span class="string">&quot;    b:&quot;</span>&lt;&lt;be&lt;&lt;<span class="string">&quot;    c:&quot;</span>&lt;&lt;ce&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//        cout &lt;&lt; &quot;total cost: &quot; &lt;&lt; cost &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 非线性优化 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
